# -*- coding: utf-8 -*-
# =====================================================================================================================
# These bindings were automatically generated by cyWrap. Please do dot modify.
# Additional functionality shall be implemented in sub-classes.
#
__copyright__ = "Copyright 2016 EPFL BBP-project"
# =====================================================================================================================
from cython.operator cimport dereference as deref
from libcpp cimport bool
cimport std
from _globalns cimport *
cimport MVD
cimport MVD2
cimport MVD3
from libcpp.memory cimport unique_ptr
from libcpp cimport bool
from cython cimport view
cimport boost
from libc cimport stdio
cimport MVD_MVDType
import numpy

cdef enum OPERATOR:
    LESS = 0, LESS_EQUAL, EQUAL, DIFF, GREATER, GREATER_EQUAL


cdef class _py__base:
    cdef void *_ptr
    # Basic comparison is done by comparing the inner obj ptr
    def __richcmp__(_py__base self, _py__base other, operation):
        if operation == OPERATOR.EQUAL:
            return self._ptr==other._ptr



# ======================================================================================================================
# Python bindings to namespace
# ======================================================================================================================


# ======================================================================================================================
# Python bindings to namespace MVD2
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
cdef class MVD2File(_py__base):
    "Python wrapper class for MVD2File (ns=MVD2)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[MVD2.MVD2File] _autodealoc
    cdef MVD2.MVD2File *ptr(self):
        return <MVD2.MVD2File*> self._ptr


    def __init__(self, std.string filename):
        self._ptr = new MVD2.MVD2File(filename)
        self._autodealoc.reset(self.ptr())

    def getNbMorphoType(self, ):
        return self.ptr().getNbMorphoType()

    def getNbMorpho(self, ):
        return self.ptr().getNbMorpho()

    def getNbNeuron(self, ):
        return self.ptr().getNbNeuron()

    def getNbColumns(self, ):
        return self.ptr().getNbColumns()

    @staticmethod
    cdef MVD2File from_ptr(MVD2.MVD2File *ptr):
        cdef MVD2File obj = MVD2File.__new__(MVD2File)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj

    @staticmethod
    cdef MVD2File from_ref(const MVD2.MVD2File &ref):
        return MVD2File.from_ptr(<MVD2.MVD2File*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[MVD2.MVD2File*] vec ):
        return [ MVD2File.from_ptr(elem) for elem in vec ]



# ----------------------------------------------------------------------------------------------------------------------
cdef class _MVD2_Counter(_py__base):
    "Python wrapper class for Counter (ns=MVD2)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[MVD2.Counter] _autodealoc
    cdef MVD2.Counter *ptr(self):
        return <MVD2.Counter*> self._ptr


    def __init__(self, std.size_t nb_neuron, std.size_t nb_morpho_type, std.size_t columns):
        self._ptr = new MVD2.Counter(nb_neuron, nb_morpho_type, columns)
        self._autodealoc.reset(self.ptr())

    def __call__(self, int type_, char[:] line):
        return deref(self.ptr())(<MVD2.DataSet> type_, &line[0])

    @staticmethod
    cdef _MVD2_Counter from_ptr(MVD2.Counter *ptr):
        cdef _MVD2_Counter obj = _MVD2_Counter.__new__(_MVD2_Counter)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj

    @staticmethod
    cdef _MVD2_Counter from_ref(const MVD2.Counter &ref):
        return _MVD2_Counter.from_ptr(<MVD2.Counter*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[MVD2.Counter*] vec ):
        return [ _MVD2_Counter.from_ptr(elem) for elem in vec ]




# ======================================================================================================================
# Python bindings to namespace MVD3
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
cdef class _MVD3_Range(_py__base):
    "Python wrapper class for Range (ns=MVD3)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[MVD3.Range] _autodealoc
    cdef MVD3.Range *ptr(self):
        return <MVD3.Range*> self._ptr


    def __init__(self, std.size_t offset_, std.size_t count_):
        self._ptr = new MVD3.Range(offset_, count_)
        self._autodealoc.reset(self.ptr())

    @staticmethod
    cdef _MVD3_Range from_ptr(MVD3.Range *ptr):
        cdef _MVD3_Range obj = _MVD3_Range.__new__(_MVD3_Range)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj

    @staticmethod
    cdef _MVD3_Range from_ref(const MVD3.Range &ref):
        return _MVD3_Range.from_ptr(<MVD3.Range*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[MVD3.Range*] vec ):
        return [ _MVD3_Range.from_ptr(elem) for elem in vec ]



# ----------------------------------------------------------------------------------------------------------------------
cdef class MVD3File(_py__base):
    "Python wrapper class for MVD3File (ns=MVD3)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[MVD3.MVD3File] _autodealoc
    cdef MVD3.MVD3File *ptr(self):
        return <MVD3.MVD3File*> self._ptr

    def __init__(self, std.string filename):
        self._ptr = new MVD3.MVD3File(filename)
        self._autodealoc.reset(self.ptr())

    def getNbNeuron(self, ):
        return self.ptr().getNbNeuron()


    def getPositions(self, _MVD3_Range range_=None):
        cdef MVD3.Positions* posics
        if range_ is None:
            posics = new MVD3.Positions(self.ptr().getPositions())
        else:
            posics = new MVD3.Positions(self.ptr().getPositions(deref(range_.ptr())))

        cdef double *addr = posics.data()
        cdef const boost.size_type* shape = posics.shape()
        cdef int x1=shape[0], x2=shape[1]
        cdef double[:,::1]y = <double[:x1,:x2]> addr
        return numpy.asarray(y)


    def getRotations(self, _MVD3_Range range_):
        cdef MVD3.Rotations *rots
        if range_ is None:
            rots = new MVD3.Rotations(self.ptr().getRotations())
        else:
            rots = new MVD3.Rotations(self.ptr().getRotations(deref(range_.ptr())))

        cdef double *addr = rots.data()
        cdef const boost.size_type* shape = rots.shape()
        cdef int x1=shape[0], x2=shape[1]
        cdef double[:,::1]y = <double[:x1,:x2]> addr
        return numpy.asarray(y)


    # def getPositions(self, _py_Range range_=None):
    #     cdef MVD3.Positions *posics = new MVD3.Positions()
    #
    #     if range_ is not None:
    #         self.ptr().getPositions(deref(posics), ))
    #     else:
    #         self.ptr().getPositions(deref(posics))
    #
    #     cdef double *addr = posics.data()
    #     cdef const boost.size_type* shape = posics.shape()
    #     cdef int x1=shape[0], x2=shape[1]
    #     cdef double[:,::1]y = <double[:x1,:x2]> addr
    #     return y

    # def getRotations(self, _py_Range range_):
    #     cdef MVD3.Rotations *rots = new MVD3.Rotations()
    #     if range_ is not None:
    #         self.ptr().getRotations(deref(rots), deref(range_.ptr()))
    #     else:
    #         self.ptr().getRotations(deref(rots))
    #     cdef double *addr = rots.data()
    #     cdef const boost.size_type* shape = rots.shape()
    #     cdef int x1=shape[0], x2=shape[1]
    #     cdef double[:,::1]y = <double[:x1,:x2]> addr
    #     return y

    def getMorphologies(self, _MVD3_Range range):
        return self.ptr().getMorphologies(deref(range.ptr()))

    def getEtypes(self, _MVD3_Range range):
        return self.ptr().getEtypes(deref(range.ptr()))

    def getMtypes(self, _MVD3_Range range):
        return self.ptr().getMtypes(deref(range.ptr()))

    def getSynapseClass(self, _MVD3_Range range):
        return self.ptr().getSynapseClass(deref(range.ptr()))

    def getIndexMorphologies(self, _MVD3_Range range):
        return self.ptr().getIndexMorphologies(deref(range.ptr()))

    def getIndexEtypes(self, _MVD3_Range range):
        return self.ptr().getIndexEtypes(deref(range.ptr()))

    def getIndexMtypes(self, _MVD3_Range range):
        return self.ptr().getIndexMtypes(deref(range.ptr()))

    def getIndexSynapseClass(self, _MVD3_Range range):
        return self.ptr().getIndexSynapseClass(deref(range.ptr()))

    def listAllMorphologies(self, ):
        return self.ptr().listAllMorphologies()

    def listAllEtypes(self, ):
        return self.ptr().listAllEtypes()

    def listAllMtypes(self, ):
        return self.ptr().listAllMtypes()

    def listAllSynapseClass(self, ):
        return self.ptr().listAllSynapseClass()

    def getCircuitSeeds(self, ):
        return self.ptr().getCircuitSeeds()

    @staticmethod
    cdef MVD3File from_ptr(MVD3.MVD3File *ptr):
        cdef MVD3File obj = MVD3File.__new__(MVD3File)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj

    @staticmethod
    cdef MVD3File from_ref(const MVD3.MVD3File &ref):
        return MVD3File.from_ptr(<MVD3.MVD3File*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[MVD3.MVD3File*] vec ):
        return [ MVD3File.from_ptr(elem) for elem in vec ]




# ======================================================================================================================
# Python bindings to namespace MVD
# ======================================================================================================================
def is_mvd_file(std.string filename):
    return MVD.is_mvd_file(filename)



# #####################################################
# NAMESPACE Aliasing
#
class MVD2:
    File = MVD2File
    Counter = _MVD2_Counter

class MVD3:
    File = MVD3File
    Range = _MVD3_Range
